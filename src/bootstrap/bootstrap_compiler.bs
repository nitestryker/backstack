
# Bootstrap compiler for Backstack written in Backstack
# This implements a simple self-hosting compiler for Backstack

# Variables to track program state
0 set:token_pos        # Current position in the token stream
0 array_new set:tokens # Array to store tokens
0 array_new set:program # Array to store compiled program
"" set:current_token   # Current token being processed
0 array_new set:functions # Store function definitions
0 set:label_counter    # Counter for generating unique labels

# Token types
0 set:TOKEN_INTEGER
1 set:TOKEN_STRING
2 set:TOKEN_IDENTIFIER
3 set:TOKEN_COMMENT
4 set:TOKEN_OPERATOR
5 set:TOKEN_KEYWORD

# Operation codes - matching those in the Python implementation
100 set:OP_PUSH
101 set:OP_PUSH_STR
102 set:OP_PLUS
103 set:OP_MINUS
104 set:OP_MULT
105 set:OP_DIV
106 set:OP_MOD
107 set:OP_DUMP
108 set:OP_SET_VAR
109 set:OP_GET_VAR
110 set:OP_EQ
111 set:OP_NEQ
112 set:OP_GT
113 set:OP_LT
114 set:OP_FUNC_DEF
115 set:OP_FUNC_CALL
116 set:OP_RETURN
120 set:OP_ARRAY_NEW
121 set:OP_ARRAY_SET
122 set:OP_ARRAY_GET
123 set:OP_ARRAY_LEN

# Function to generate a unique label
fun:gen_label
  get:label_counter
  1 +
  set:label_counter
  "label_" get:label_counter str_concat
  return
fun_end

# Function to check if a token is a number
fun:is_number
  # Expect token on stack
  "0123456789-" set:digits
  
  # Check if first character is a digit or minus sign
  dup 0 1 str_slice
  get:digits str_contains
  
  if
    # It starts with a digit or minus, assume it's a number
    1
  else
    0
  end_if
  
  return
fun_end

# Function to tokenize input
fun:tokenize
  "Tokenizing input..." dump
  
  # For a real implementation, we would read the input file
  # and split it into tokens based on whitespace and other delimiters
  
  # Simulated tokenization of a simple program
  10 array_new set:tokens  # Create token array
  
  # Push a sample program tokens
  0 get:tokens "42" array_set
  1 get:tokens "13" array_set
  2 get:tokens "+" array_set
  3 get:tokens "dump" array_set
  4 get:tokens "\"Hello, World!\"" array_set
  5 get:tokens "dump" array_set
  6 get:tokens "set:x" array_set
  7 get:tokens "get:x" array_set
  8 get:tokens "dump" array_set
  
  get:tokens
  return
fun_end

# Function to parse a token and generate code
fun:parse_token
  # Expect token on stack
  set:current_token
  get:current_token
  
  # Check if it's a number
  dup call:is_number
  
  if
    # Parse number
    get:OP_PUSH
    get:current_token
    # In a real implementation, we would convert string to int
    # For now, just use a dummy value
    42
    2 array_new
    get:program swap array_append
    set:program
  else
    # Check for string literals
    get:current_token 0 1 str_slice "\"" ==
    
    if
      # Parse string literal
      get:OP_PUSH_STR
      get:current_token 1 get:current_token str_length 1 - str_slice  # Remove quotes
      2 array_new
      get:program swap array_append
      set:program
    else
      # Check for keywords and operators
      get:current_token "+" ==
      
      if
        get:OP_PLUS
        1 array_new
        get:program swap array_append
        set:program
      else
        get:current_token "-" ==
        
        if
          get:OP_MINUS
          1 array_new
          get:program swap array_append
          set:program
        else
          get:current_token "*" ==
          
          if
            get:OP_MULT
            1 array_new
            get:program swap array_append
            set:program
          else
            get:current_token "dump" ==
            
            if
              get:OP_DUMP
              1 array_new
              get:program swap array_append
              set:program
            else
              # Check for variable operations
              get:current_token "set:" str_contains
              
              if
                get:OP_SET_VAR
                get:current_token 4 get:current_token str_length str_slice
                2 array_new
                get:program swap array_append
                set:program
              else
                get:current_token "get:" str_contains
                
                if
                  get:OP_GET_VAR
                  get:current_token 4 get:current_token str_length str_slice
                  2 array_new
                  get:program swap array_append
                  set:program
                end_if
              end_if
            end_if
          end_if
        end_if
      end_if
    end_if
  end_if
  
  return
fun_end

# Function to parse tokens
fun:parse
  "Parsing tokens..." dump
  0 array_new set:program
  
  0 set:i
  
  while get:i get:tokens array_len <
    get:tokens get:i array_get
    call:parse_token
    
    get:i 1 + set:i
  end_while
  
  get:program
  return
fun_end

# Function to emit assembly code
fun:emit
  "Emitting code..." dump
  
  # In a real implementation, this would generate assembly code
  # For this bootstrap version, we'll just print the operations
  
  "section .data" dump
  "    fmt_int db \"%lld\", 10, 0" dump
  "    fmt_str db \"%s\", 10, 0" dump
  "" dump
  "section .text" dump
  "    global main" dump
  "    extern printf" dump
  "" dump
  "main:" dump
  "    push rbp" dump
  "    mov rbp, rsp" dump
  
  0 set:i
  
  while get:i get:program array_len <
    get:program get:i array_get set:op
    
    get:op 0 array_get get:OP_PUSH ==
    
    if
      "    ; Push value" dump
      "    mov rax, " get:op 1 array_get str_concat dump
      "    push rax" dump
    else
      get:op 0 array_get get:OP_PUSH_STR ==
      
      if
        "    ; Push string" dump
        "    lea rax, [rel str_0]" dump
        "    push rax" dump
      else
        get:op 0 array_get get:OP_PLUS ==
        
        if
          "    ; Add" dump
          "    pop rbx" dump
          "    pop rax" dump
          "    add rax, rbx" dump
          "    push rax" dump
        else
          get:op 0 array_get get:OP_DUMP ==
          
          if
            "    ; Dump" dump
            "    pop rdi" dump
            "    lea rcx, [rel fmt_int]" dump
            "    call printf" dump
          end_if
        end_if
      end_if
    end_if
    
    get:i 1 + set:i
  end_while
  
  "    ; Exit program" dump
  "    xor rax, rax" dump
  "    pop rbp" dump
  "    ret" dump
  
  return
fun_end

# Main function
fun:main
  "Backstack bootstrap compiler starting..." dump
  
  call:tokenize set:tokens
  "Tokens: " get:tokens dump
  
  get:tokens call:parse set:program
  "Program: " get:program dump
  
  get:program call:emit
  
  "Compilation complete!" dump
  return
fun_end

# Start the compiler
call:main
